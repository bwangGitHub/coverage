/*
 *  Copyright 2001-2005 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time;

/**
 * DateTimeConstants is a non-instantiable class of constants used in
 * the date time system. These are the ISO8601 constants, but should be
 * used by all chronologies.
 * <p>
 * DateTimeConstants is thread-safe and immutable.
 *
 * @author Stephen Colebourne
 * @author Brian S O'Neill
 * @since 1.0
 */
public class DateTimeConstants {
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.ping();
  }


    // These are ints not enumerations as they represent genuine int values
    /** Constant (1) representing January, the first month (ISO) */
    public static final int JANUARY = 1;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[1]++;
  }

    /** Constant (2) representing February, the second month (ISO) */
    public static final int FEBRUARY = 2;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[2]++;
  }

    /** Constant (3) representing March, the third month (ISO) */
    public static final int MARCH = 3;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[3]++;
  }

    /** Constant (4) representing April, the fourth month (ISO) */
    public static final int APRIL = 4;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[4]++;
  }

    /** Constant (5) representing May, the fifth month (ISO) */
    public static final int MAY = 5;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[5]++;
  }

    /** Constant (6) representing June, the sixth month (ISO) */
    public static final int JUNE = 6;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[6]++;
  }

    /** Constant (7) representing July, the seventh month (ISO) */
    public static final int JULY = 7;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[7]++;
  }

    /** Constant (8) representing August, the eighth month (ISO) */
    public static final int AUGUST = 8;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[8]++;
  }

    /** Constant (9) representing September, the nineth month (ISO) */
    public static final int SEPTEMBER = 9;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[9]++;
  }

    /** Constant (10) representing October, the tenth month (ISO) */
    public static final int OCTOBER = 10;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[10]++;
  }

    /** Constant (11) representing November, the eleventh month (ISO) */
    public static final int NOVEMBER = 11;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[11]++;
  }

    /** Constant (12) representing December, the twelfth month (ISO) */
    public static final int DECEMBER = 12;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[12]++;
  }

    // These are ints not enumerations as they represent genuine int values
    /** Constant (1) representing Monday, the first day of the week (ISO) */
    public static final int MONDAY = 1;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[13]++;
  }

    /** Constant (2) representing Tuesday, the second day of the week (ISO) */
    public static final int TUESDAY = 2;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[14]++;
  }

    /** Constant (3) representing Wednesday, the third day of the week (ISO) */
    public static final int WEDNESDAY = 3;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[15]++;
  }

    /** Constant (4) representing Thursday, the fourth day of the week (ISO) */
    public static final int THURSDAY = 4;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[16]++;
  }

    /** Constant (5) representing Friday, the fifth day of the week (ISO) */
    public static final int FRIDAY = 5;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[17]++;
  }

    /** Constant (6) representing Saturday, the sixth day of the week (ISO) */
    public static final int SATURDAY = 6;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[18]++;
  }

    /** Constant (7) representing Sunday, the seventh day of the week (ISO) */
    public static final int SUNDAY = 7;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[19]++;
  }


    /** Constant (0) representing AM, the morning (from Calendar) */
    public static final int AM = 0;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[20]++;
  }

    /** Constant (1) representing PM, the afternoon (from Calendar) */
    public static final int PM = 1;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[21]++;
  }


    /** Constant (0) representing BC, years before zero (from Calendar) */
    public static final int BC = 0;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[22]++;
  }
    /** Alternative constant (0) representing BCE, Before Common Era (secular) */
    public static final int BCE = 0;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[23]++;
  }

    /**
     * Constant (1) representing AD, years after zero (from Calendar).
     * <p>
     * All new chronologies with differrent Era values should try to assign
     * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
     * the value 1. Earlier eras are assigned sequentially smaller numbers.
     * Later eras are assigned sequentially greater numbers.
     */
    public static final int AD = 1;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[24]++;
  }
    /**
     * Alternative constant (1) representing CE, Common Era (secular).
     * <p>
     * All new chronologies with differrent Era values should try to assign
     * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned
     * the value 1. Earlier eras are assigned sequentially smaller numbers.
     * Later eras are assigned sequentially greater numbers.
     */
    public static final int CE = 1;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[25]++;
  }


    /** Milliseconds in one second (1000) (ISO) */
    public static final int MILLIS_PER_SECOND = 1000;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[26]++;
  }

    /** Seconds in one minute (60) (ISO) */
    public static final int SECONDS_PER_MINUTE = 60;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[27]++;
  }
    /** Milliseconds in one minute (ISO) */
    public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[28]++;
  }

    /** Minutes in one hour (ISO) */
    public static final int MINUTES_PER_HOUR = 60;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[29]++;
  }
    /** Seconds in one hour (ISO) */
    public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[30]++;
  }
    /** Milliseconds in one hour (ISO) */
    public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[31]++;
  }

    /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the
     * number of hours per day can vary. */
    public static final int HOURS_PER_DAY = 24;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[32]++;
  }
    /** Minutes in a typical day (ISO). Due to time zone offset changes, the number
     * of minutes per day can vary. */
    public static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[33]++;
  }
    /** Seconds in a typical day (ISO). Due to time zone offset changes, the number
     * of seconds per day can vary. */
    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[34]++;
  }
    /** Milliseconds in a typical day (ISO). Due to time zone offset changes, the
     * number of milliseconds per day can vary. */
    public static final int MILLIS_PER_DAY = MILLIS_PER_HOUR * HOURS_PER_DAY;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[35]++;
  }

    /** Days in one week (7) (ISO) */
    public static final int DAYS_PER_WEEK = 7;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[36]++;
  }
    /** Hours in a typical week. Due to time zone offset changes, the number of
     * hours per week can vary. */
    public static final int HOURS_PER_WEEK = HOURS_PER_DAY * DAYS_PER_WEEK;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[37]++;
  }
    /** Minutes in a typical week (ISO). Due to time zone offset changes, the number
     * of minutes per week can vary. */
    public static final int MINUTES_PER_WEEK = MINUTES_PER_DAY * DAYS_PER_WEEK;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[38]++;
  }
    /** Seconds in a typical week (ISO). Due to time zone offset changes, the number
     * of seconds per week can vary. */
    public static final int SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[39]++;
  }
    /** Milliseconds in a typical week (ISO). Due to time zone offset changes, the
     * number of milliseconds per week can vary. */
    public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;
  static {
    CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx.statements[40]++;
  }

    /**
     * Restrictive constructor
     */
    protected DateTimeConstants() {
    }

}

class CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx extends org.codecover.instrumentation.java.measurement.CounterContainer {

  static {
    org.codecover.instrumentation.java.measurement.ProtocolImpl.getInstance(org.codecover.instrumentation.java.measurement.CoverageResultLogFile.getInstance(null), "fc723371-5766-4804-90bc-1687dd8f2639").addObservedContainer(new CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx ());
  }
    public static long[] statements = new long[41];
    public static long[] branches = new long[0];
    public static long[] loops = new long[1];

  public CodeCoverCoverageCounter$b7x136z3gysgwjdkpfkpnz9nns8n9hzwwx () {
    super("org.joda.time.DateTimeConstants.java");
  }

  public static void ping() {/* nothing to do*/}

  public void reset() {
      for (int i = 1; i <= 40; i++) {
        statements[i] = 0L;
      }
      for (int i = 1; i <= -1; i++) {
        branches[i] = 0L;
      }
      for (int i = 1; i <= 0; i++) {
        loops[i] = 0L;
      }
  }

  public void serializeAndReset(org.codecover.instrumentation.measurement.CoverageCounterLog log) {
    log.startNamedSection("org.joda.time.DateTimeConstants.java");
      for (int i = 1; i <= 40; i++) {
        if (statements[i] != 0L) {
          log.passCounter("S" + i, statements[i]);
          statements[i] = 0L;
        }
      }
      for (int i = 1; i <= -1; i++) {
        if (branches[i] != 0L) {
          log.passCounter("B"+ i, branches[i]);
          branches[i] = 0L;
        }
      }
      for (int i = 1; i <= 0; i++) {
        if (loops[i * 3 - 2] != 0L) {
          log.passCounter("L" + i + "-0", loops[i * 3 - 2]);
          loops[i * 3 - 2] = 0L;
        }
        if ( loops[i * 3 - 1] != 0L) {
          log.passCounter("L" + i + "-1", loops[i * 3 - 1]);
          loops[i * 3 - 1] = 0L;
        }
        if ( loops[i * 3] != 0L) {
          log.passCounter("L" + i + "-2", loops[i * 3]);
          loops[i * 3] = 0L;
        }
      }
  }
}

